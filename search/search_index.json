{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pandora Short Term Scheduler","text":"<p>This software is deisgned to generate a short term science calendar of Pandora observations. This code takes as input a long term calendar and an updated orbital ephemeris and gnerates a new short term calendar for delivery to the Mission Operations Center.</p> <p>There is an example notebook included in the example.</p>"},{"location":"apidocs/","title":"API Documentation","text":"<p>This file generates API reference documentation using <code>mkdocstrings</code> for the package contained in this repository. It is a simple starting point \u2014 update the entries below to document the modules you care about.</p> <p>shortschedule - Science Calendar Processing and Scheduling</p>"},{"location":"apidocs/#shortschedule.ObservationSequence","title":"<code>ObservationSequence</code>","text":"<p>Represents an observation sequence within a visit.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.duration","title":"<code>duration</code>  <code>property</code>","text":"<p>Return the sequence duration as an Astropy TimeDelta.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.duration--returns","title":"Returns","text":"<p>astropy.time.TimeDelta     TimeDelta representing stop_time - start_time. The caller can     convert to seconds/minutes/hours via <code>.sec</code> or astropy unit methods.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.start_time_str","title":"<code>start_time_str</code>  <code>property</code>","text":"<p>Format start time as ISO string with Z suffix.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.stop_time_str","title":"<code>stop_time_str</code>  <code>property</code>","text":"<p>Format stop time as ISO string with Z suffix.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.copy","title":"<code>copy()</code>","text":"<p>Create a deep copy of this observation sequence.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.get_all_payload_parameters","title":"<code>get_all_payload_parameters()</code>","text":"<p>Return all payload parameters as a nested dictionary.</p> <p>The returned structure converts XML elements into Python-native types (strings, dicts, lists) making it easier to inspect payload values in tests and analysis code.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.get_flat_payload_parameters","title":"<code>get_flat_payload_parameters()</code>","text":"<p>Return a flattened mapping of payload parameters.</p> <p>Keys use dot-notation to represent nesting (e.g. 'AcquireVisCamScienceData.ExposureTime_us'). Attributes are represented using the '@' prefix (e.g. 'Payload.@attr').</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.get_nested_payload_parameter","title":"<code>get_nested_payload_parameter(category, parameter_name, sub_parameter_name, default=None)</code>","text":"<p>Get nested payload parameter value.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.get_payload_parameter","title":"<code>get_payload_parameter(category, parameter_name, default=None)</code>","text":"<p>Retrieve a payload parameter from the stored XML payload element.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.get_payload_parameter--parameters","title":"Parameters","text":"<p>category : str     Top-level payload category name (e.g. 'AcquireVisCamScienceData'). parameter_name : str     Child element name to retrieve under the category element. default : any, optional     Value to return if the parameter or category is not present.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.get_payload_parameter--returns","title":"Returns","text":"<p>str or dict or None     - If the element is a leaf with text, a stripped string is returned.     - If the element has children, a dict mapping child tag -&gt; value is returned.     - If missing, <code>default</code> is returned.</p>"},{"location":"apidocs/#shortschedule.ObservationSequence.set_payload_parameter","title":"<code>set_payload_parameter(category, parameter_name, value)</code>","text":"<p>Set payload parameter value in XML structure.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor","title":"<code>ScheduleProcessor</code>","text":"<p>Main class for processing and adjusting science calendars with updated TLE.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor--public-methods","title":"Public methods","text":"<ul> <li>process_calendar(calendar, window_start=None, window_duration_days=21, verbose=False)     Process a calendar and return an updated ScienceCalendar.</li> <li>get_gap_report()     Return a structured report summarizing visibility gaps and actions taken.</li> </ul> <p>The class expects <code>Visibility(tle1, tle2)</code> to offer <code>get_visibility(coord, times)</code> returning a boolean array of the same length as <code>times</code>.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.debug_sequence_visibility","title":"<code>debug_sequence_visibility(calendar, sequence_id, target_name=None)</code>","text":"<p>Debug visibility for a specific sequence.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.get_gap_report","title":"<code>get_gap_report()</code>","text":"<p>Return comprehensive gap analysis report.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.get_minute_by_minute_assignments","title":"<code>get_minute_by_minute_assignments(calendar)</code>","text":"<p>Generate assignments using synchronized time grid.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.print_gap_summary","title":"<code>print_gap_summary()</code>","text":"<p>Print a human-readable summary of gap analysis.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.print_timing_summary","title":"<code>print_timing_summary(calendar)</code>","text":"<p>Print a quick timing summary.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.process_calendar","title":"<code>process_calendar(calendar, window_start=None, window_duration_days=21, verbose=False)</code>","text":"<p>Process a <code>ScienceCalendar</code> and return an updated calendar.</p> <p>The processor performs a time-window extraction, computes minute-by-minute visibility using the configured TLEs, identifies visibility gaps, attempts to fill gaps by extending previous sequences (and shrinking following sequences), updates payload integration parameters, and produces a <code>gap_report</code> summary.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.process_calendar--side-effects","title":"Side effects","text":"<ul> <li>The returned <code>ScienceCalendar</code> will have its <code>.metadata</code> updated   to include the TLE lines, a <code>processed_datetime</code> and the   generated <code>gap_report</code> to aid downstream writing and analysis.</li> </ul>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.process_calendar--parameters","title":"Parameters","text":"<p>calendar : ScienceCalendar     Input calendar to process. window_start : str or astropy.time.Time, optional     ISO string or Time object indicating the window start. window_duration_days : int, optional     Number of days to include in the processing window. verbose : bool, optional     Print diagnostics when True.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.process_calendar--returns","title":"Returns","text":"<p>ScienceCalendar     Processed calendar with updated sequences and metadata.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_no_overlaps_astropy","title":"<code>validate_no_overlaps_astropy(calendar, report_issues=True)</code>","text":"<p>Use Astropy's time comparison with proper tolerance.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_payload_exposures","title":"<code>validate_payload_exposures(calendar, report_issues=True)</code>","text":"<p>Validate that payload exposure times (single exposure and total requested exposure) do not exceed the enclosing sequence duration.</p> <p>This currently checks the common VIS camera payload category <code>AcquireVisCamScienceData</code> for keys:   - <code>ExposureTime_us</code> (microseconds per frame)   - <code>NumTotalFramesRequested</code> (total frames)   - <code>FramesPerCoadd</code> (used when NumTotalFramesRequested is not present)</p> <p>It also heuristically scans flattened payload parameters for any key containing the string <code>exposure</code> and checks single-exposure values against the sequence duration (assumes microseconds when the key ends with <code>_us</code>).</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_payload_exposures--returns","title":"Returns","text":"<p>list     A list of issue dicts found. Empty list if none.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_roll_consistency","title":"<code>validate_roll_consistency(calendar, report_issues=True, tolerance_deg=0.001)</code>","text":"<p>Validate that all sequences of the same target within a visit have consistent roll angles.</p> <p>For each visit, sequences with the same target name should have the same roll angle (within tolerance). This ensures the spacecraft maintains consistent orientation for all observations of the same target during a visit.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_roll_consistency--parameters","title":"Parameters","text":"<p>calendar : ScienceCalendar     The science calendar to validate. report_issues : bool, optional     If True (default), print issues found. If False, only return issues. tolerance_deg : float, optional     Maximum allowed difference in roll angle (degrees) between     sequences of the same target. Default is 0.001 degrees.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_roll_consistency--returns","title":"Returns","text":"<p>list of dict     A list of issue dictionaries. Each dictionary contains:         - 'visit_id': The visit ID where the issue was found.         - 'target': The target name with inconsistent roll.         - 'sequence_ids': List of sequence IDs with this target.         - 'roll_values': List of roll values for these sequences.         - 'max_difference_deg': Maximum difference in roll values.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_sequence_timing","title":"<code>validate_sequence_timing(calendar, report_issues=True)</code>","text":"<p>Comprehensive timing validation including overlaps, gaps, and minimum durations.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_sequence_timing--returns","title":"Returns","text":"<p>dict     Dictionary with different types of timing issues</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_star_roi_consistency","title":"<code>validate_star_roi_consistency(calendar, report_issues=True)</code>","text":"<p>Validate MaxNumStarRois/numPredefinedStarRois consistency.</p> <p>According to flight software requirements: - Method 0, 1, 3: MaxNumStarRois should equal numPredefinedStarRois - Method 2: numPredefinedStarRois should be 0, MaxNumStarRois should be &gt; 0</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_star_roi_consistency--parameters","title":"Parameters","text":"<p>calendar : ScienceCalendar     The science calendar to validate. report_issues : bool, optional     If True (default), issues are reported in the returned list. If False,     the function still performs validation but does not print or log issues.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_star_roi_consistency--returns","title":"Returns","text":"<p>list of dict     A list of issue dictionaries found. Each dictionary contains:         - 'visit_id': The visit ID where the issue was found.         - 'sequence_id': The sequence ID where the issue was found.         - 'problem': A string describing the type of problem.         - 'StarRoiDetMethod': The value of StarRoiDetMethod.         - 'numPredefinedStarRois': The value of numPredefinedStarRois.         - 'MaxNumStarRois': The value of MaxNumStarRois.     Returns an empty list if no issues are found.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_star_roi_consistency--problem-types","title":"Problem Types","text":"<p>The 'problem' key in each issue dict can have values such as:     - \"MaxNumStarRois != numPredefinedStarRois for method 0/1/3\"     - \"numPredefinedStarRois != 0 for method 2\"     - \"MaxNumStarRois &lt;= 0 for method 2\"</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_star_roi_consistency--examples","title":"Examples","text":"<p>issues = processor.validate_star_roi_consistency(calendar) issues[0] {     'visit_id': 'V001',     'sequence_id': 'S001',     'problem': 'MaxNumStarRois != numPredefinedStarRois for method 0/1/3',     'star_roi_det_method': 1,     'num_predefined': 3,     'max_num': 2 }</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_target_names","title":"<code>validate_target_names(calendar, report_issues=True)</code>","text":"<p>Validate that all target names do not contain spaces.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_target_names--parameters","title":"Parameters","text":"<p>calendar : ScienceCalendar     The calendar to validate. report_issues : bool, optional     If True, print issues to stdout.</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_target_names--returns","title":"Returns","text":"<p>List[Dict[str, Any]]     List of issues found. Each issue is a dict with:     - sequence_id: str     - target: str     - visit_id: str</p>"},{"location":"apidocs/#shortschedule.ScheduleProcessor.validate_visibility","title":"<code>validate_visibility(calendar, report_issues=True)</code>","text":"<p>Validate that all sequences have good visibility.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar","title":"<code>ScienceCalendar</code>","text":"<p>Represents a complete Science Calendar.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.calendar_span","title":"<code>calendar_span</code>  <code>property</code>","text":"<p>Total span of the calendar from first to last observation.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.calendar_span_days","title":"<code>calendar_span_days</code>  <code>property</code>","text":"<p>Total span of the calendar from first to last observation in days.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.date_range","title":"<code>date_range</code>  <code>property</code>","text":"<p>Start and end dates of the calendar.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.duty_cycle_percent","title":"<code>duty_cycle_percent</code>  <code>property</code>","text":"<p>Percentage of calendar span that is actually observing.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.priority_breakdown","title":"<code>priority_breakdown</code>  <code>property</code>","text":"<p>Breakdown of sequences by priority level.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.total_duration","title":"<code>total_duration</code>  <code>property</code>","text":"<p>Total duration of all observations in minutes.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.total_duration_days","title":"<code>total_duration_days</code>  <code>property</code>","text":"<p>Total duration of all observations in days.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.total_duration_hours","title":"<code>total_duration_hours</code>  <code>property</code>","text":"<p>Total duration of all observations in hours.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.total_duration_minutes","title":"<code>total_duration_minutes</code>  <code>property</code>","text":"<p>Total duration of all observations in minutes.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.total_sequences","title":"<code>total_sequences</code>  <code>property</code>","text":"<p>Total number of observation sequences.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.copy","title":"<code>copy()</code>","text":"<p>Create a complete deep copy of this calendar.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.get_sequence","title":"<code>get_sequence(visit_id, sequence_id)</code>","text":"<p>Get observation sequence by visit ID and sequence ID.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.get_summary_stats","title":"<code>get_summary_stats()</code>","text":"<p>Get comprehensive summary statistics.</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.replace_sequence","title":"<code>replace_sequence(visit_id, sequence_id, new_sequence)</code>","text":"<p>Replace an existing sequence with a new one.</p> <p>Parameters:</p> Name Type Description Default <code>visit_id</code> <code>str</code> <p>ID of the visit containing the sequence</p> required <code>sequence_id</code> <code>str</code> <p>ID of the sequence to replace</p> required <code>new_sequence</code> <code>ObservationSequence</code> <p>New ObservationSequence object to replace with</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if replacement was successful, False if sequence not found</p>"},{"location":"apidocs/#shortschedule.ScienceCalendar.set_visibility_calculator","title":"<code>set_visibility_calculator(visibility)</code>","text":"<p>Set or update the visibility calculator.</p>"},{"location":"apidocs/#shortschedule.Visit","title":"<code>Visit</code>","text":"<p>Represents a visit in the science calendar.</p>"},{"location":"apidocs/#shortschedule.Visit.end_time","title":"<code>end_time</code>  <code>property</code>","text":"<p>End time of the last sequence in this visit.</p>"},{"location":"apidocs/#shortschedule.Visit.start_time","title":"<code>start_time</code>  <code>property</code>","text":"<p>Start time of the first sequence in this visit.</p>"},{"location":"apidocs/#shortschedule.Visit.total_duration","title":"<code>total_duration</code>  <code>property</code>","text":"<p>Total duration of all sequences in this visit.</p>"},{"location":"apidocs/#shortschedule.Visit.total_duration_minutes","title":"<code>total_duration_minutes</code>  <code>property</code>","text":"<p>Total duration of all sequences in this visit (minutes).</p>"},{"location":"apidocs/#shortschedule.Visit.copy","title":"<code>copy(sequences=None)</code>","text":"<p>Create a copy of this visit, optionally with different sequences.</p>"},{"location":"apidocs/#shortschedule.XMLWriter","title":"<code>XMLWriter</code>","text":"<p>Class for writing processed science calendars back to XML format.</p> <p>The writer provides <code>write_calendar(calendar, output_path=None, ...)</code> which either writes to the provided <code>output_path</code> or generates a filename using the PAN naming convention.</p>"},{"location":"apidocs/#shortschedule.XMLWriter.write_calendar","title":"<code>write_calendar(calendar, output_path=None, mission_phase='TST', revision=1, verbose=False)</code>","text":"<p>Write science calendar to XML file with proper naming convention.</p>"},{"location":"apidocs/#shortschedule.XMLWriter.write_calendar--parameters","title":"Parameters:","text":"<p>calendar : ScienceCalendar     Calendar to write output_path : str, optional     Full output path. If None, generates filename automatically mission_phase : str     Mission phase code: 'TST', 'COM', or 'OPS' (default: 'TST') revision : int     Revision number (default: 1) verbose : bool     Print writing details</p>"},{"location":"apidocs/#shortschedule.XMLWriter.write_calendar--returns","title":"Returns:","text":"<p>str     Path to written file</p>"},{"location":"apidocs/#shortschedule.apply_rolls_to_calendar","title":"<code>apply_rolls_to_calendar(calendar, verbose=False)</code>","text":"<p>Apply roll angles to all visits in a science calendar.</p> <p>This is a convenience function that applies roll angles to all visits in a calendar, ensuring consistency within each visit.</p>"},{"location":"apidocs/#shortschedule.apply_rolls_to_calendar--parameters","title":"Parameters","text":"<p>calendar : ScienceCalendar     The calendar to update. Modified in place. verbose : bool, optional     If True, print progress information.</p>"},{"location":"apidocs/#shortschedule.apply_rolls_to_calendar--returns","title":"Returns","text":"<p>None     The calendar is modified in place.</p>"},{"location":"apidocs/#shortschedule.apply_rolls_to_visit","title":"<code>apply_rolls_to_visit(visit, target_rolls=None)</code>","text":"<p>Apply roll angles to all observation sequences in a visit.</p> <p>This function modifies the visit's sequences in place, setting the roll attribute on each ObservationSequence.</p>"},{"location":"apidocs/#shortschedule.apply_rolls_to_visit--parameters","title":"Parameters","text":"<p>visit : Visit     The visit to update. Modified in place. target_rolls : dict, optional     Pre-calculated mapping of target name to roll angle.     If None, rolls will be calculated using calculate_visit_rolls().</p>"},{"location":"apidocs/#shortschedule.apply_rolls_to_visit--returns","title":"Returns","text":"<p>None     The visit is modified in place.</p>"},{"location":"apidocs/#shortschedule.calculate_roll","title":"<code>calculate_roll(ra, dec, obs_time)</code>","text":"<p>Calculate the spacecraft roll angle for a given target and time.</p> <p>The roll angle is computed based on the position of the target relative to the Sun at the time of observation. This ensures proper solar panel orientation.</p>"},{"location":"apidocs/#shortschedule.calculate_roll--parameters","title":"Parameters","text":"<p>ra : float     Right ascension of the target in degrees. dec : float     Declination of the target in degrees. obs_time : Time     The time of observation (used to determine Sun position).</p>"},{"location":"apidocs/#shortschedule.calculate_roll--returns","title":"Returns","text":"<p>float     The spacecraft roll angle in degrees, in the range [0, 360).</p>"},{"location":"apidocs/#shortschedule.get_version","title":"<code>get_version()</code>","text":"<p>Get package version.</p>"},{"location":"apidocs/#shortschedule.parse_science_calendar","title":"<code>parse_science_calendar(xml_path, verbose=False)</code>","text":"<p>Parse a PAN-SCICAL Science Calendar XML file into a <code>ScienceCalendar</code> object.</p>"},{"location":"apidocs/#shortschedule.parse_science_calendar--parameters","title":"Parameters","text":"<p>xml_path : str     Path to the PAN-SCICAL XML file. verbose : bool, optional     If True, print progress messages.</p>"},{"location":"apidocs/#shortschedule.parse_science_calendar--returns","title":"Returns","text":"<p>ScienceCalendar     In-memory representation of the calendar with visits and observation     sequences. Payload parameter XML fragments are preserved as     ElementTree elements under each sequence.</p>"},{"location":"apidocs/#shortschedule.parse_science_calendar--notes","title":"Notes","text":"<p>The parser tolerates missing optional sections and returns an empty <code>ScienceCalendar</code> when no visits are found. It uses the namespace '/pandora/calendar/' expected in PAN-SCICAL files.</p>"},{"location":"apidocs/#shortschedule.setup_logging","title":"<code>setup_logging(level=logging.INFO)</code>","text":"<p>Setup basic logging configuration.</p>"},{"location":"apidocs/#shortschedule.setup_logging--parameters","title":"Parameters:","text":"<p>level : int     Logging level (default: logging.INFO)</p>"},{"location":"notebook-example/","title":"Example using the short calendar generation","text":"<p>You can create notebooks to show how to use your package. These will be automatically compiled and run by <code>mkdocs</code>, depending on the settings in your <code>mkdocs.yml</code> file.</p> In\u00a0[1]: Copied! <pre>from shortschedule import ScheduleProcessor, XMLWriter\nfrom shortschedule import ScienceCalendar, Visit, ObservationSequence\nfrom shortschedule import parse_science_calendar\nfrom shortschedule.visualizer import ScheduleVisualizer\n\nfrom astropy.time import Time\n</pre> from shortschedule import ScheduleProcessor, XMLWriter from shortschedule import ScienceCalendar, Visit, ObservationSequence from shortschedule import parse_science_calendar from shortschedule.visualizer import ScheduleVisualizer  from astropy.time import Time In\u00a0[2]: Copied! <pre># this is an example XML file that lasts for 7 days\nxml_file_path = \"../src/shortschedule/data/Pandora_science_calendar_20251018_tsb-futz.xml\"\n</pre> # this is an example XML file that lasts for 7 days xml_file_path = \"../src/shortschedule/data/Pandora_science_calendar_20251018_tsb-futz.xml\"  In\u00a0[3]: Copied! <pre># set a start date for the new calendar and duration\nwindow_start = Time(\"2026-02-05T00:00:00Z\")\nwindow_duration_days = 3\n\n# parse the long term calendar XML file\noriginal_calendar = parse_science_calendar(xml_file_path, verbose=True)\n\n\n# save the original TLE here for testing\n# the new TLE has a slightly different number of orbits per day\noriginal_tle1 = \"1 99152U 26011B  26005.66013674 +.00000000 +00000-0 +00000-0 0   16\"\noriginal_tle2 = \"2 99152 97.6750 17.6690 0000000 328.8990 20.9640 14.86530781000004\"\n\n# new_tle1 = \"1 99152U 26011B  26005.66013674 +.00000000 +00000-0 +00000-0 0   16\"\n# new_tle2 = \"2 99152 97.6750 17.6690 0000000 328.8990 20.9640 14.865\"\n\n# new_tle1 = \"1 99999U 26001A 26005.54166667  .00000000  00000-0  00000-0 0  001\"\n# new_tle2 = \"2 99999 97.80100 22.77800 0016727 107.62000 173.84550 14.92118033 2\"\n\n# testing with no changes\nnew_tle1 = \"1 99152U 26011B  26005.66013674 +.00000000 +00000-0 +00000-0 0   16\"\nnew_tle2 = \"2 99152 97.6750 17.6690 0000000 328.8990 20.9640 14.86530781000004\"\n\n# initialize the ScheduleProcessor object\nscheduler = ScheduleProcessor(new_tle1, new_tle2)\n</pre> # set a start date for the new calendar and duration window_start = Time(\"2026-02-05T00:00:00Z\") window_duration_days = 3  # parse the long term calendar XML file original_calendar = parse_science_calendar(xml_file_path, verbose=True)   # save the original TLE here for testing # the new TLE has a slightly different number of orbits per day original_tle1 = \"1 99152U 26011B  26005.66013674 +.00000000 +00000-0 +00000-0 0   16\" original_tle2 = \"2 99152 97.6750 17.6690 0000000 328.8990 20.9640 14.86530781000004\"  # new_tle1 = \"1 99152U 26011B  26005.66013674 +.00000000 +00000-0 +00000-0 0   16\" # new_tle2 = \"2 99152 97.6750 17.6690 0000000 328.8990 20.9640 14.865\"  # new_tle1 = \"1 99999U 26001A 26005.54166667  .00000000  00000-0  00000-0 0  001\" # new_tle2 = \"2 99999 97.80100 22.77800 0016727 107.62000 173.84550 14.92118033 2\"  # testing with no changes new_tle1 = \"1 99152U 26011B  26005.66013674 +.00000000 +00000-0 +00000-0 0   16\" new_tle2 = \"2 99152 97.6750 17.6690 0000000 328.8990 20.9640 14.86530781000004\"  # initialize the ScheduleProcessor object scheduler = ScheduleProcessor(new_tle1, new_tle2) <pre>Parsing XML file: ../src/shortschedule/data/Pandora_science_calendar_20251018_tsb-futz.xml\nRoot tag: {/pandora/calendar/}ScienceCalendar\nCalendar valid from 2026-02-05 00:00:00 to 2027-02-04 09:47:00\nFound 10 visits\nSuccessfully parsed 10 visits with 313 total sequences\n</pre> In\u00a0[4]: Copied! <pre># create the new calendar\n\nprocessed_calendar = scheduler.process_calendar(original_calendar,\n                           window_start=window_start,\n                           window_duration_days = window_duration_days\n                           )\n</pre> # create the new calendar  processed_calendar = scheduler.process_calendar(original_calendar,                            window_start=window_start,                            window_duration_days = window_duration_days                            ) In\u00a0[5]: Copied! <pre># these tests are performed internally but we can also run them explicitly\nissues = scheduler.validate_visibility(processed_calendar)\nprint('visibility issues:', issues)\n\nissues = scheduler.validate_payload_exposures(processed_calendar, report_issues=True)\nprint('exposure issues:', issues)\n\n# Quick overlap check (like validate_visibility)\noverlap_issues = scheduler.validate_no_overlaps_astropy(processed_calendar)\nprint(f\"Found {len(overlap_issues)} overlaps\")\n\n# Comprehensive timing validation\nall_timing_issues = scheduler.validate_sequence_timing(processed_calendar)\n\n# Quick summary\nscheduler.print_timing_summary(processed_calendar)\n\nscheduler.print_gap_summary()\n</pre> # these tests are performed internally but we can also run them explicitly issues = scheduler.validate_visibility(processed_calendar) print('visibility issues:', issues)  issues = scheduler.validate_payload_exposures(processed_calendar, report_issues=True) print('exposure issues:', issues)  # Quick overlap check (like validate_visibility) overlap_issues = scheduler.validate_no_overlaps_astropy(processed_calendar) print(f\"Found {len(overlap_issues)} overlaps\")  # Comprehensive timing validation all_timing_issues = scheduler.validate_sequence_timing(processed_calendar)  # Quick summary scheduler.print_timing_summary(processed_calendar)  scheduler.print_gap_summary()  <pre>visibility issues: []\nexposure issues: []\nFound 0 overlaps\n\n============================================================\nSEQUENCE TIMING VALIDATION REPORT\n============================================================\nTotal sequences analyzed: 136\nTotal timing issues found: 0\n\n\u2713 OVERLAPS: None found\n\n\u2713 SHORT SEQUENCES: None found\n\n\u2713 LARGE GAPS: None found\n\u2713 All sequence timing validation checks passed\n\n============================================================\nVISIBILITY GAP ANALYSIS SUMMARY\n============================================================\n\nORIGINAL CALENDAR:\n  Total Sequences: 136\n  Total Duration: 70.8 hours\n  Duty Cycle: 97.9%\n\nPROCESSED CALENDAR:\n  Total Sequences: 136\n  Total Duration: 72.2 hours\n  Duty Cycle: 100.0%\n\nIMPROVEMENTS:\n  Duration Gained: 1.5 hours\n  Duty Cycle Improved: 2.1%\n  Sequences Modified: 0\n  Gaps Filled: 38/38\n</pre> In\u00a0[6]: Copied! <pre>processed_calendar.get_summary_stats()\n</pre> processed_calendar.get_summary_stats() Out[6]: <pre>{'total_visits': 6,\n 'total_sequences': np.int64(136),\n 'total_duration_minutes': np.float64(4335.0),\n 'total_duration_hours': np.float64(72.25),\n 'total_duration_days': np.float64(3.0104166666666665),\n 'calendar_span_days': np.float64(3.0104166666666665),\n 'duty_cycle_percent': np.float64(100.0),\n 'start_date': '2026-02-05T00:00:00.000',\n 'end_date': '2026-02-08T00:15:00.000',\n 'priority_breakdown': {'priority_1': {'count': 28,\n   'duration_hours': np.float64(23.200000000000003),\n   'duration_days': np.float64(0.9666666666666668)},\n  'priority_0': {'count': 105,\n   'duration_hours': np.float64(46.43333333333333),\n   'duration_days': np.float64(1.9347222222222222)},\n  'priority_2': {'count': 3,\n   'duration_hours': np.float64(2.616666666666666),\n   'duration_days': np.float64(0.10902777777777774)}}}</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[7]: Copied! <pre># we can write the output file\nXMLWriter().write_calendar(processed_calendar, )\n</pre> # we can write the output file XMLWriter().write_calendar(processed_calendar, ) Out[7]: <pre>'PAN-SCICAL-TST-20251123-VF-20260205-EX-20260208-R001.xml'</pre> In\u00a0[8]: Copied! <pre># show some example figures\nvisualizer = ScheduleVisualizer(scheduler)\npriority_fig = visualizer.plot_gantt_timeline_by_priority(\n    processed_calendar,\n    figsize=(12, 6),  # Smaller size\n    show_sequence_labels=False,\n    title=\"Schedule by Priority\"\n)\n</pre> # show some example figures visualizer = ScheduleVisualizer(scheduler) priority_fig = visualizer.plot_gantt_timeline_by_priority(     processed_calendar,     figsize=(12, 6),  # Smaller size     show_sequence_labels=False,     title=\"Schedule by Priority\" ) In\u00a0[9]: Copied! <pre># we can compare before and after\n\nwindowed_original = scheduler._extract_time_window(\n    original_calendar,\n    window_start=window_start,\n    window_duration_days=window_duration_days,\n    verbose=False\n)\n\ngantt_fig, visit_fig, summary_fig, comparison_df = visualizer.generate_full_report(\n    windowed_original, \n    processed_calendar,\n    save_path=\"schedule_analysis\",\n    show_sequence_labels=False,  # Clean look without sequence IDs\n    processed_only=False          # Only show processed calendar\n)\n</pre> # we can compare before and after  windowed_original = scheduler._extract_time_window(     original_calendar,     window_start=window_start,     window_duration_days=window_duration_days,     verbose=False )  gantt_fig, visit_fig, summary_fig, comparison_df = visualizer.generate_full_report(     windowed_original,      processed_calendar,     save_path=\"schedule_analysis\",     show_sequence_labels=False,  # Clean look without sequence IDs     processed_only=False          # Only show processed calendar ) <pre>Plots and data saved to schedule_analysis_*\n</pre> In\u00a0[10]: Copied! <pre># there are a lot of helper functions\n\nprocessed_calendar.visits[0].sequences[0].get_all_payload_parameters()\n</pre> # there are a lot of helper functions  processed_calendar.visits[0].sequences[0].get_all_payload_parameters() Out[10]: <pre>{'AcquireInfCamImages': {'AverageGroups': '1',\n  'ROI_StartX': '1968',\n  'ROI_StartY': '824',\n  'ROI_SizeX': '80',\n  'ROI_SizeY': '400',\n  'RiceX': '4',\n  'RiceY': '28',\n  'SaveImagesToDisk': '1',\n  'SendThumbnails': '1',\n  'ThumbnailBinSize': '1',\n  'ThumbnailCompressionType': '1',\n  'TargetID': 'TOI-674b',\n  'SC_Resets1': '1',\n  'SC_Resets2': '1',\n  'SC_DropFrames1': '0',\n  'SC_DropFrames2': '16',\n  'SC_DropFrames3': '0',\n  'SC_ReadFrames': '4',\n  'SC_Groups': '6',\n  'SC_Integrations': '33'},\n 'AcquireVisCamScienceData': {'IncludeFieldSolnsInResp': '1',\n  'ROI_StartX': '512',\n  'ROI_StartY': '512',\n  'ROI_SizeX': '1024',\n  'ROI_SizeY': '1024',\n  'MaxMagnitudeInQuadCatalog': '15.5',\n  'SaveImagesToDisk': '1',\n  'RiceX': '5',\n  'RiceY': '25',\n  'SendThumbnails': '0',\n  'TargetID': 'TOI-674b',\n  'TargetRA': '164.58597139355507',\n  'TargetDEC': '-36.85811973960063',\n  'StarRoiDetMethod': '1',\n  'numPredefinedStarRois': '9',\n  'PredefinedStarRoiRa': {'RA1': '164.586531',\n   'RA2': '164.619144',\n   'RA3': '164.794141',\n   'RA4': '164.461044',\n   'RA5': '164.483215',\n   'RA6': '164.773688',\n   'RA7': '164.781431',\n   'RA8': '164.712959',\n   'RA9': '164.687437'},\n  'PredefinedStarRoiDec': {'Dec1': '-36.858110',\n   'Dec2': '-36.683878',\n   'Dec3': '-36.878746',\n   'Dec4': '-37.012308',\n   'Dec5': '-36.812367',\n   'Dec6': '-36.830616',\n   'Dec7': '-36.990587',\n   'Dec8': '-36.953811',\n   'Dec9': '-36.748922'},\n  'FramesPerCoadd': '50',\n  'ExposureTime_us': '200000',\n  'MaxNumStarRois': '0',\n  'StarRoiDimension': '50',\n  'NumTotalFramesRequested': '6550'}}</pre> In\u00a0[11]: Copied! <pre>fig, ax = visualizer.plot_timeline(processed_calendar, show_visits=True)\n</pre> fig, ax = visualizer.plot_timeline(processed_calendar, show_visits=True) In\u00a0[12]: Copied! <pre>fig, ax = visualizer.plot_target_time(processed_calendar)\n</pre> fig, ax = visualizer.plot_target_time(processed_calendar) In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"notebook-example/#example-using-the-short-calendar-generation","title":"Example using the short calendar generation\u00b6","text":""}]}